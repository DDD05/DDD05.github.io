<?xml version="1.0" encoding="utf-8"?>
<search>
  
    <entry>
      <title><![CDATA[scoped packages - npm package 앞에 골뱅이란?]]></title>
      <url>/npm/2021/02/09/scoped-packages/</url>
      <content type="text"><![CDATA[Scoped packagesDescription모든 npm package는 이름을 가지고있습니다. 그리고 약간의 패키지들은 scope를 가지고있습니다. 이런 스코프를 가지고있는 패키지들은 이름을 정하는 룰이 있습니다. 바로 @ symbol과 slash를 사용하는 것이죠.@somescope/somepackagename이것을 scoped packages 라고 부르며 npm에 새로 추가된 기능입니다.npm 패키지에 네임스페이스를 적용하여 아래와 같은 규칙을 정합니다.  global modules : 현재 존재하는 컨벤션 네임을 따른 모듈.  scoped modules : 조직이나 그룹에 “scoped” 된 새로운 모듈.Installing scoped packages일반적인 패키지들은 node_modules/packagename 형식으로 설치됩니다. scoped modules은 node_modules/@myorg/packagename의 경로로 설치됩니다.@ symbol, in npm install :npm install @myorg/mypackageOr in package.json :"dependencies": {        "@myorg/mypackage" : "^1.3.0"}  [참고] https://docs.npmjs.com/cli/v6/using-npm/scope]]></content>
      <categories>
        
          <category> NPM </category>
        
      </categories>
      <tags>
        
          <tag> node.js </tag>
        
          <tag> NPM </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[구닥다리 공룡을 위한 오늘날의 JavaScript]]></title>
      <url>/javascript/2021/02/03/ModernJavaScriptExplainedForDinosaurs/</url>
      <content type="text"><![CDATA[Modern JavaScript Explained For Dinosaurs오늘날 자바스크립트를 공부하는 것은 힘들다. 특히나 초창기부터 자바스크립트를 접하지 않은 사람이라면 더욱이..!그정도로 자바스크립트의 생태계는 엄청 빠르게 성장하고 변하기 때문에 다양한 도구로 해결하는 문제 자체가 이해하기 어려워 졌다.Browserify라는 태그라인을 알고있는가?  “Browserify는 브라우저에서 require(‘modules’)를 사용하여 모든 의존성을 통합할 수 있다.” 라는 설명 문장으로 설명되어 있지만 이해하기 어렵다 😅이 글에서는 website(단순한 HTML, JavaScript 외에 어떤 도구도 사용되지 않는)를 만들어 보고, 차차 구식 frontend 개발 생태계의 문제점들을 해결하는 도구들을 하나씩 소개할 예정이다.구식 자바스크립트일단, 수동으로 파일들을 다운받고 연결하는 구식 웹사이트로 시작해 본다.이 웹사이트는 HTML과 자바스크립트를 사용한다. 여기 하나의 자바스크립트 파일이 연결된 간단한 index.html이 있다.&lt;!-- index.html --&gt;&lt;!DOCTYPE html&gt;&lt;html lang="ko"&gt;&lt;head&gt;    &lt;meta charset="UTF-8"&gt;    &lt;title&gt;자바스크립트 Example&lt;/title&gt;    &lt;script src="index.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;    &lt;h1&gt;Hello from HTML!&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;이 행은 index.html과 같은 디렉토리에 있는 별도의 자바스크립트 파일인 index.js를 참조한다. index.js의 내용은 아래와 같다.console.log("Hello from 자바스크립트!");이게 웹사이트를 만드는데 필요한 전부이다. 이제 여기에 외부 라이브러리를 추가할 예정이다. moment.js는 날짜 형식을 사람이 읽기 쉬운 형식으로 바꿀때 유용한 라이브러리이다. 예를 들어 아래와 같이 moment함수를 사용할 수 있다.moment().startOf('day').fromNow();  // 20 hours ago그치만 이건 어디까지나 moment.js를 현재 웹사이트에 포함시켰단 가정하에 이야기이다. moment.js의 홈페이지를 방문해 보면 아래와 같은 지시사항을 볼 수 있다.오른쪽 인스톨 섹션은 일단 무시하자. index.html이 들어있는 디렉토리에 moment.min.js를 다운로드 한다. 그러면 아래의 코드처럼 index.html에 moment.min.js를 추가 시킬 수 있다.&lt;!-- index.html --&gt;&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;  &lt;meta charset="UTF-8"&gt;  &lt;title&gt;Example&lt;/title&gt;  &lt;link rel="stylesheet" href="index.css"&gt;  &lt;script src="`moment.min.js`"&gt;&lt;/script&gt;  &lt;script src="index.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;  &lt;h1&gt;Hello from HTML!&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;moment.min.js가 index.js보다 앞서 로드 되고 있다는걸 주의해야한다. 이말은 index.js안에서 moment함수를 사용할 수 있게 되었다는것을 의미한다.// index.jsconsole.log("Hello from 자바스크립트!");console.log(moment().startOf('day').fromNow());그리고 이게 바로 웹사이트에 자바스크립트 라이브러리를 사용하는 방식이다(완전 구식😜 ). 이해하기 쉽다는게 이 방식의 장점이고, 단점은 라이브러리 제작자가 업데이트를 할 때마다 그것의 새 버전을 매번 찾아야 하고 다운로드하기 번거롭다는 것이다.자바스크립트 패키지 매니저(npm) 사용하기2010년 즈음, 중앙 레포지토리로부터 라이브러리 다운로드와 업그레이드를 자동화 해주는, 여러 경쟁적인 자바스크립트 패키지 매니저가 등장했다.2013년 Bower는 거의 이껸 없이 최고의 인기 제품이었다 하지만, 2015년 즈음하여 npm이 그 인기를 따라잡았다. 2016년 말부부터는 yarn이 npm 인터페이스의 대안으로 나타났지만 yarn 역시 npm 패키지를 내부적으로 사용하고 있다.npm은 원래 node.js를 위해 특별히 만들어진 패키지 매니저라는 점을 염두해야 한다. node.js는 프론트엔드가 아닌 서버 위에서 구동되도록 설계된 자바스크립트 실행 환경으로써 브라우저에서 실행되는 JS 라이브러리들을 위한 프론트엔드 자바스크립트 패키지 매니저로 선택했다는 건 꽤 괴팍하다고 할 수 있다. 서버 환경에서 쓰던걸 프론트엔드 환경에서 쓰려는 것이기 때문이다  🎈 Tip: 패키지 매니저를 쓴다는 것은 보통 커맨드라인 사용과 연관있다. 이전 프론트엔드 개발 방식(완전 구식)에서는 전혀 필요 없던 부분이다.하지만 지금은 커맨드라인은 땔 수 없는 존재가 되었다. 커맨드라인을 사용함으로써 다른 개발 영역으로의 다양한 문을 열 수 있을 것이다.완전 구식 방식의 단점으로 번거롭게 매번 수동으로 다운받는 것을 대신하여 npm을 사용하여 moment.js 패키지를 자동으로 설치하는지 확인 해보자.npm을 사용하기 위해서는 node.js가 설치되어 있어야한다. LTS 버전을 이용하도록하자.  🔨 버전 설치: 버전을 고를때는 신중해야한다. 너무 최신 버전을 고르는것 보다 두 버전을 낮춰서 설치하는 것을 추천한다. node.js 같은 경우 LTS 버전이 있는데 여기서는 이것을 선택한다. LTS(Long Term Support)로 오랫동안 이 버전에 대해 서포팅을 한다는 뜻인듯…커맨드라인으로 index.html이 있는 디렉토리로 이동한 후 다음 명령어를 입력해봐야한다.$ npm init이 명령어를 입력하면 몇 가지 질의응답 과정이 이어지고, 응답은 기본 값으로 충분하다(모두 엔터키). 그러면 package.json이라는 새로운 파일 하나가 생성된다. 이 파일을 configuration(설정, 구성) 파일로 npm이 이 프로젝트에 대한 모든 정보를 저장하는데 사용된다. 기본적인 package.json의 내용은 아래와 같다.{    "name": "my-project-name",    "version": "1.0.0",    "description": "",    "main": "index.js",    "scripts": {        "test": "echo \"Error: no test specified\" &amp;&amp; exit 1"    },    "author": "",    "license": "ISC"}이제 moment.js 자바스크립트 패키지를 설치하기 위해서 moment.js의 홈페이지에 안내되어 있는 명렁어를 커맨드라인에 입력해야한다.$ npm install moment이 명령어를 통해 두가지 일이 수행된다. 첫번째 moment.js 패키지의 모든 코드를 내려받아 node_modules라는 폴더에 저장한다. 둘째로 package.json 파일이 아래로 수정된다. 이것으로 프로젝트가 의존성을 갖는 moment.js를 지속적으로 추적하도록 한다.{    "name": "modern-자바스크립트-example",    "version": "1.0.0",    "description": "",    "main": "index.js",    "scripts": {        "test": "echo \"Error: no test specified\" &amp;&amp; exit 1"    },    "author": "",    "license": "ISC",    "dependencies": {        "moment": "^2.19.1"    }}이는 나중에 다른 개발자와 프로젝트를 공유할때 유용하게 사용된다. 보통 용량이 큰 node_modules 폴더를 직접 공유하는 대신 package.json 파일을 공유함으로써 다른 개발자들이 필요한 패키지들을 자동으로 설치할 수 있도록 한다.  ➡️ npm install 명령어를 통해서이제 더이상 프로젝트에 수동으로 moment.js를 내려받을 필요가 없어졌다. npm을 이용하여 자동으로 다운로드 받고 업데이트 받을 수 있다. node_modules 폴더 안을 살펴보면 moment.min.js 파일이 node_modules/moment/min 디렉토리 안에 있을것이다. ➡️ npm으로 다운로드 한 moment.min.js를 index.html에 연결 할 수 있다는 의미이다!!&lt;!-- index.html --&gt;&lt;!DOCTYPE html&gt;&lt;html lang="ko"&gt;&lt;head&gt;  &lt;meta charset="UTF-8"&gt;  &lt;title&gt;JavaScript Example&lt;/title&gt;  &lt;script src="node_modules/moment/min/moment.min.js"&gt;&lt;/script&gt;  &lt;script src="index.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;  &lt;h1&gt;Hello from HTML!&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;커맨드라인으로 npm을 사용해 우리의 패키지들을 다운로드하고 업데이트 할 수 있다는 장점이 있다.이 상황에서 나쁜 점은 패키지가 실제로 담겨있는 node_modules 폴더의 깊은 곳까지 파고들어야지만 수동으로 HTML에 불러올 수 있다는 것(꽤 나 불편).그래서 이제는 자동으로 처리해 주는 방법을 살펴볼 예정이다.자바스크립트 모듈 번들러(webpack) 사용하기대부분의 프로그래밍 언어들이 하나의 코드에서 다른 코드를 불러들이는 방법을 제공한다. 하지만 자바스크립트는 이런 기능이 없었다. 그 이유는 자바스크립트는 오직 브라우저 환경에서만 구동되도록 만들어졌고 보안상의 이유로 컴퓨터의 파일 시스템에 접근 할 수 없기 때문이다. 그래서 오랜 시간동안 다수의 파일로 자바스크립트 코드를 구성하는 일은 각 파일을 전역 변수로 할당하여 공유해야만 했다.이전의 구식적으로 사용한 행위 역시 위 메커니즘을 이용하여 사용하였따. 예를 들어 전체 moment.min.js 파일은 HTML로 로드 된다. 그 안에 정의 되어있는 변수 moment는 전역 변수가 된다. 그 후에 로드 되는 모든 파일에서는 이 전역변수를 사용 할 수 있게된다.2009년, CommonJS라는 이름의 프로젝트가 시작된다. 이것을 목표는 브라우저 외의 자바스크립트 생태계를 만드는 것이다. CommmonJS의 대부분은 모듈에 대한 명세이다. 이 명세로 마침내 자바스크립트가다른 대부분의 프로그래밍 언어들 처럼 파일을 통해 코드를 들여오고(import) 내보낼(export) 수 있게 된다. 전역 변수에 할당하는 방법 대신에… 이 CommonJS 모듈의 구현체 중 가장 유명한 것이 바로 node.js이다.node.js는 서버에서 구동되도록 설계된 자바스크립트 실행 환경이다.초기 node.js 모듈 사용 예시를 살펴보자. moment.min.js를 HTML script tag로 불러오는 것 대신 자바스크립트 파일을 직접 자바스크립트 안에 불러올 수 있다.// index.jsvar moment = require('moment');console.log("Hello from 자바스크립트!");console.log(moment().startOf('day').fromNow());이것이 node.js에서 작동하는 모듈 로딩 방식이다. node.js가 컴퓨터의 파일 시스템에 접근 가능한 서버 사이드 언어이기에 가능한 것. node.js는 또 각 npm 모듈이 어느 경로에 위치하는지 알고 있다.이 덕분에 require('./node_modules/moment/min/moment.min.js')라고 쓰는 대신 require('moment')라고 쓸 수 잇다. 👍node.js가 이렇게 좋지만, 위 코드를 부라우저 상에서 실행 하려고 하면 require가 정의되지 않았다는 에러가 뜬다. 😅 브라우저는 파일 시스템에 접근 권한이 없어서인데 이를 해결하기위한 방법은 매우 까다롭다.. 파일들을 불러오는 것이 (실행속도를 느리게 하는)동기적인 것이든 (타이밍 문제가 있는)비동기적인 것이든 동적으로 수행되어야만 한다.  require와 같은 모듈 로딩 구문은 실행시에 그 구문이 로드한 다른 파일의 코드로 대친된다.이러한 부분이 바로 모듈 번들러가 필요해 지는 지점이다. 자바스크립트 모듈번들러는 파일 시스템에 접근 할 수 있는 빌드 단계에서 위와 같은 문제를 해결하여 브라우저와 호환되는 (파일 시스템에 엑세스 할 필요가 없는) 최종 결과물을 만들어내는 도구이다. 여기서 우리는 모든 require 구문을 찾아내어 이를 (실제 요구된 파일)실제 내용으로 대치시켜주는 모듈 번들러가 필요해진다. 이때 최종적인 결과물은 하나로 묶인(bundled) (require 구문이 없는) 단일 자바스크립트 파일인 되느 것이다.!!가장 인기있었던 모듈 번들러는 Browserify로, node.js 방식의 require구문을 프론트엔드에 사용하는데 있어 선구자적 역할을 했다. 근본적으로 npm이 프론트엔드 패키지 매니저가 될 수 있게 만들어준셈이다. 그 후 webpack이 등장하면서 더 보편적으로 사용되는 모듈 번들러로 자리매김한다.  webpack의 이점을 몽땅 활용 가능한 프론트엔드 프레임워크인 React의 인기가 높아짐       React는 프레임워크가 아닌 라이브러리.  webpack 살펴보기webpack을 써야 require('moment') 예제를 브라우저에서 돌릴 수 있다. 젤 처음으로 webpack을 프로젝트에 추가해야된다. webpack 자체는 그저 npm 패키지이고, 따라서 아래 커맨드로 설치 할 수 있다.$ npm install webpack webpack-cli --save-dev  🎈 tip : --save-dev 인수로 설치하면 패키지가 개발용 의존으로 저장된다.       패키지가 개발 환경에서만 쓰이고 서버에 올라간 제품 상태에선 사용하지 않을 것이란 의미.    package.json에도 자동으로 반영됨.       {"name": "modern-자바스크립트-example","버전": "1.0.0","description": "","main": "index.js","scripts": {  "test": "echo \"에러: no test specified\" &amp;&amp; exit 1"},"author": "","license": "ISC","dependencies": {  "moment": "^2.19.1"},"devDependencies": {  "webpack": "^5.21.2",  "webpack-cli": "^4.5.0"}}            webpack이 패키지 중 하나로써 node_modules 폴더에 설치가 된다. 커맨드라인에 아래처럼 입력함으로써 webpack을 사용할 수 있다.$ ./node_modules/.bin/webpack index.js --mode=development이 명령은 node_modules에 설치되어 있는 webpack 도구를 실행시킨다. 실행되는 도구는 index.js 파일을 읽기 시작하여 require 구문을 찾고 이를 다른 파일의 코드로 대치시킨 최종 결과물로써 dist/main.js를 출력한다. 이제 HTML에서 더 이상 (require 구문이 있는)index.js를 쓸 수 없게 된다. 하지만 dist/main.js를 쓰면된다.&lt;!-- index.html --&gt;&lt;!DOCTYPE html&gt;&lt;html lang="ko"&gt;&lt;head&gt;  &lt;meta charset="UTF-8"&gt;  &lt;title&gt;자바스크립트 Example&lt;/title&gt;  &lt;script src="dist/main.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;  &lt;h1&gt;Hello from HTML!&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;브라우저를 새로고침 해보면 이전과 마찬가지로 모든 것이 정상 작동하는 것을 볼 수 있다.index.js가 수정 될 때마다 webpack 명열을 실행해야 하는데 이것은 상당히 귀찮다. 여기에 webpack의 고급 기능을 사용하면 더 귀찮아진다.이 점을 해결하기위해서 webpack은 config(설정) 파일로부터 옵션들을 설정할 수 있다. 이 config 파일은 프로젝트의 root 폴더에 위치하며 webpack.config.js로 만들면 된다.// webpack.config.jsmodule.exports = {    mode: 'development',    entry: './index.js',    output: {      filename: 'main.js',      publicPath: 'dist'    }  };위와 같이 설정을 해두면 이제 index.js가 변경될 때 마다 아래 명령어를 통해 사용할 수 있다.$ ./node_modules/.bin/webpackwebpack.config.js에 설정한 옵션들을 webpack이 알아서 읽기 때문에 좀 더 편한 방법이다. 그러나 명령어를 매번 입력하는 것도 역시 귀찮다. 이걸 좀더 편하게 만들어 보자.지금까지 워크 플로우엔 상당한 이점이 있는데 더이상 전역변수로 외부 스크립트를 불러들일 필요가 없는 점이다. 어느 자바스크립트 라이브러리도 HTML 태그 대신 자바스크립트의 require 구문을 통해 추가될 것이다. 단일 자바스크립트 묶음 파일을 갖는 것은 성능면에서도 더 좋다. 그리고 이제 또 다른 강력한 기능들을 개발 workflow에 추가 할 수 있는 빌드 단계가 추가된다.언어의 새로운 기능을 사용하기 위한 transpiling (bable)  [참고] https://medium.com/the-node-js-collection/modern-javascript-explained-for-dinosaurs-f695e9747b70 https://steemit.com/javascript/@march23hare/javascript]]></content>
      <categories>
        
          <category> JavaScript </category>
        
      </categories>
      <tags>
        
          <tag> JavaScript </tag>
        
          <tag> NPM </tag>
        
          <tag> webpack </tag>
        
          <tag> babel </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[[WEB] PRG 패턴]]></title>
      <url>/web/2021/01/29/web-prg-pattern/</url>
      <content type="text"><![CDATA[PRG (POST-Redirect-GET) 패턴이란?PRG 패턴은 웹 개발 시에 권장되는 디자인 패턴 중 하나로, HTTP POST 요청에 대한 응답이 또 다른 URL로의 GET 요청을 위한 리다이렉트(응답 코드가 3xx)여야 한다는 것을 의마한다. 즉, 일반적인 HTTP GET 요청처럼 HTTP POST 요청에 대한 응답이 어떠한 페이지를 직접 반환하는 것은 권장되지 않는 위험한 방식이라는 것이다.PRG 패턴의 필요성PRG 패턴을 사용하지 않는다면, 대표적으로 다음과 같은 두가지 문제점이 발생할 수 있다.새로고침으로 인해 동일한 HTTP POST 요청이 중복으로 발생하여 의도치 않은 결과를 낳을 수 있다.만약 HTTP POST 요청에 대한 응답이 단순히 어떠한 페이지를 직접 반환하는 것이라면, 이후 새로고침을 시도했을 때 방금 전 HTTP POST 요청이 그대로 다시 서버에 전송된다. 이는 의도치 않은 결과를 낳을 수 있다.예를 들어, 온라인 물품 구매 후 새로고침을 하면 중복 구매가 이뤄질 수 있다.HTTP POST 요청의 결과에 해당하는 페이지를 북마크하거나 다른 ƒ사람과 공유하는 것이 어려워진다.북마크(즐겨찾기)는 특정 HTTP 요청의 URL만을 저장하고, 다른 사람에게 해당 페이지를 공유할 때도 오로지 URL만을 공유한다. 기본적으로 사용자는 URL만 가지고는 HTTP GET 요청밖에 할 수 없기 때문에, 이는 의도와 다른 페이지로 이동하는 결과를 낳게 된다. 그러나 만약 PRG 패턴을 따른다면 HTTP POST 요청에 대한 응답을 받자 마자 다시 특정 URL로의 HTTP GET 요청을 전송하기 때문에, 해당 URL을 북마크하거나 다른 사람과 공유하는 것이 가능해진다.⬇️ PRG 패턴을 사용하지 않을 때⬇ PRG 패턴을 사용할 때(권장)  참고      https://it-eldorado.tistory.com/68    https://en.wikipedia.org/wiki/Post/Redirect/Get]]></content>
      <categories>
        
          <category> Web </category>
        
      </categories>
      <tags>
        
          <tag> Web </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[ESLint & Prettier]]></title>
      <url>/javascript/2021/01/26/eslint-prettier/</url>
      <content type="text"><![CDATA[      ESLint와 Prettier를 사용하는 이유    ESLint 적용하기    Prettier 적용하기    ESLint + Prettier    Git hook을 이용한 자동화 방법  ESLint와 Prettier를 사용하는 이유ESLint와 Prettier는 보통 프로젝트 시작 단계(초기 셋팅)에서 코드 포맷팅과 코드 품질을 위해서 사용합니다.  코드 포맷팅 : 코드 컨벤션을 설정하기 위함.  코드 품질 : 잠재적인 오류나 버그를 찾는 역할ESLint 적용하기목적코드 검사 및 수정적용 방법      node.js 설치가 필수, node package를 이용.     // .eslintrc.js module.export = { 	rules: { 		'no-unexpected-multiline': 'error', 		'no-extra-semi': 'error', 	}, }; // package.json &gt; script : { "lint" :  "eslint src" } // src에 해당하는 모든 코드를 검사 // npm run lint 명렁어 실행            package.json 파일 아래에 script 문에 { "lint" : "eslint src" }를 작성합니다.이것으로 npm run lint 명령어를 실행하면 src에 해당하는 모든 코드를 검사합니다.    --fix 옵션을 이용하여 잘못된 부분은 수정되도록 설정도 가능합니다.    eslint.org/docs/rules 을 참고하면 스패너 모양은 --fix 옵션을 이용하여 수정 가능 하다는 것을 알려줍니다.      ✔️ 표시가 되어있는 경우 "extends" : "eslint:recommended" 를 적용했을 경우 적용되는 룰입니다.    // .eslintrc.jsmodule.export = {	extends: ['eslint:recommended'],};      Prettier 적용하기목적코드 포맷팅, 코드의 일관성을 유지할 수 있습니다.적용 방법$ npm install prettier      // 설치$ npx prettier src/**/*     // 실행$ npx prettier src/**/* --write     // 실행 후 적용prettier는 eslint와 달리 규칙이 미리 셋팅되어있습니다. 따라서 추가 설정업시 바로 사용이 가능합니다.ESLint + Prettier코드 포맷팅을 맞추더라도 코드 품질과 관련된 검사는 ESLint의 몫입니다.ESLint는 prettier와 통합하는 방법을 제공해줍니다.  eslint-config-prettier와 eslint-plugin-prettier      prettier 포맷팅 규칙을 eslint에 추가합니다. 서로 충돌하는 옵션이 있다면 prettier의 규칙을 사용하도록 하는 도구입니다.    $ npm install eslint-config-prettier eslint-plugin-prettier        // .eslintrc.jsmodule.export = {	extends: ['eslint:recommended', 'plugin:prettier/recommended'],};      Git hook을 이용한 자동화 방법Git hook이란?husky를 이용, 커밋 시점에 어떤 일을 작동시킬 수 있습니다. 이것을 이용해서 커밋 시점에 ESLint를 체크할 수 있습니다.설치 방법      허스키를 설치합니다.     $ npm install husky            깃 훅 테스트 방법, 아래 페키지를 작성 후 $ git commit --allow-empty -m "husky test" 명령어 실행 =&gt; 콘솔창 확인     // package.json { 	"husky": { 		"hooks": { 			"pre-commit": "echo '커밋전 출력'" 		} 	} }            테스트 완료 후 아래로 수정     // package.json { 	"husky": { 		"hooks": { 			"pre-commit": "npm run lint" 		} 	} }      최적화위 방법은 모든 소스 코드를 검사하는 방법입니다. 만약 코드가 많아져서 모든 코드를 검사하면서 커밋이 느려질 수 있는데이럴경우 lint-staged를 이용하여 변경(스테이징)된 파일만 린트를 수행할 수 있는 도구입니다.$ npm install lint-staged// package.json{	"husky": {		"hooks": {			"pre-commit": "lint-staged"		}	},	"lint-staged": {		"*.{js,ts}": "npm run lint"	}}에디터의 확장 프로그램을 이용한 방법.커밋 시점이 아닌 개발 단계에서 ESLint &amp; Prettier 적용이 가능합니다.VS Code의 ESLint와 Prettier 확장 프로그램을 설치해서 사용합니다.사용법은 아래를 참고해주세요.// settings.json{	"eslint.enable": true,  // eslint 활성화	"editor.codeActionsOnSave": {   // 저장시 eslint 규칙에 맞게 수정		"source.fixAll.eslint": true	}}]]></content>
      <categories>
        
          <category> JavaScript </category>
        
      </categories>
      <tags>
        
          <tag> JavaScript </tag>
        
          <tag> ESLint </tag>
        
          <tag> Prettier </tag>
        
          <tag> Node.js </tag>
        
          <tag> VS Code </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Docker를 사용해서 간단한 로컬 DB 셋팅]]></title>
      <url>/docker/2021/01/22/make-local-db-container-using-docker/</url>
      <content type="text"><![CDATA[목적  같은 포트에서 간단한 명령어를 통해 여러 버전, 다양한 DB를 관리하기 위함.  작은 프로젝트라 같은 서버에 (디비+ 백 + 프론트) 배포 할 목적, 미리 배포 환경을 셋팅 할 수 있음.📖 스토리회사 동기와 간단하게 프로젝트를 진행하게 되었다.백엔드는 MySQL과 Spring을 이용하여 서버를 만들었고 간단한 미팅을 통해 DB모델링과 아키텍처를 설계하고 Back과 Front는 REST API를 통해 데이터를 주고 받으며 작업 공간을 분리하기로 하였다.백엔드쪽에서 swagger가 완성되고 아직 배포 환경이 셋팅되지않아 직접 로컬에서 서버를 실행 시켜확인해야 했고, 이러한 광정에서 도커를 이용해서 간편하게 껏다 킬 수 있는 디비를 셋팅 해볼까한다.😁⚙️ 설치 가이드도커 설치      Docker를 설치한다.        설치가 완료되면 기본적으로 튜토리얼을 실행시켜 사용하기 전 올바르게 설치되어있는지 확인할 수 있습니다. (선택)        위 명령어를 통해 도커에서 제공하는 기본 스타트 프로젝트를 클론 받습니다.        클론 받은 경로로 이동하여 도커 파일을 빌드합니다.    빌드를 성공하면 도커 이미지가 생성됩니다.        생성한 도커 이미지 파일을 80포트로 실행한다. 이렇게 되면 도커 컨테이너가 올라가게 된다. (접속가능) 브라우저에 localhost로 접속해보면 아래와 같은 화면을 볼 수 있습니다. 😋    아래와 같은 화면이 뜨면 도커가 올바르게 실행되고 있다는 뜻입니다.        도커에는 도커 허브라는 이미지를 공유하는 커뮤니티 공간이 있는데 github과 비슷합니다.    이 공간을 통해서 타사에서 제공하는 미리 셋팅된 이미지를 클론받아 빠르고 쉽게 환경을 구축 할 수 있습니다.    또 자신만의 배포 환경이나 배포 버전을 관리하여 배포하고 싶은 서버에서 클론받아 실행시켜 편리하게 환경을 구축 할 수 있습니다.       MySQL 컨테이너 실행MySQL이 도커 허브에서 이미지를 공식적으로 제공합니다.일단 원하는 DB와 버전을 확인합니다. 저는 MySQL 5.7.30 버전을 사용하기로 했습니다.터미널을 열어 docker pull mysql:tag 명령어를 실행합니다 (tag에는 버전을 기입)pull을 성공적으로 했다면 mysql 이미지가 생겼을 것이다.docker images 명령어를 통해 확인할 수 있습니다.이제 이미지를 통해 컨테이너를 생성하고 실행해보겠습니다.컨테이너 생성은 이미지를 한번이라도 실행시키면 자동으로 생성됩니다. 이렇게 만들어진 컨테이너는 명령어를 통해 작동을 컨트롤 할 수 있습니다.docker run -d -p 3306:3306 -e MYSQL_ROOT_PASSWORD=1234 --name to-do-noti-2007-db-mysql -v /Users/ddd/Documents/repository/To-do-list2007/DB:/var/lib/mysql mysql:5.7.30 --character-set-server=utf8mb4 --collation-server=utf8mb4_unicode_ci- d: 백그라운드에서 실행- p: 포트 설정- e: 환경 변수 설정- name: 컨테이너 이름- v: 저장소를 마운트 (컨테이너를 삭제 시 데이터 복구가 힘들 것 같아서)- 마지막은 실행 시킬 이미지와 버전 그리고 옵션을 추가해서 한글 입력이 가능하도록 만들었습니다.명령어를 실행하면 이제 백그라운에서 mysql container를 실행합니다.확인을 해보고 싶다면 docker ps 명령어를 입력해봅니다.  혹시나 실행되지 않는다면 기존의 설치된 DB와 포트가 충돌했을 수 있습니다.정상적으로 컨테이너가 실행되고 있는 것을 확인 할 수 있습니다.해당 DB로 접속해 보겠습니다.docker exec -it to-do-noti-2007-db-mysql bash명령어를 통해 컨테이너의 bash로 접속합니다. 다음 mysql -u root -p 명령어를 통해 설치한 mysql로 접속합니다.[심화] docker-compose로 관리  docker-compose는 도커 파일 또는 컨테이너를 효율적으로 실행시키고 설정들을 문서화하여 관리 할 수 있습니다.docker-compose.yml 파일을 만듭니다.좋은 예제가 있어서 공유하겠습니다.// docker-compose.ymlversion: "3" # 파일 규격 버전services: # 이 항목 밑에 실행하려는 컨테이너 들을 정의db: # 서비스 명    image: mysql:5.7.30 # 사용할 이미지    container_name: ddd05-todoNoti-mysql # 컨테이너 이름 설정    ports:    - "3306:3306" # 접근 포트 설정 (컨테이너 외부:컨테이너 내부)    environment: # -e 옵션    MYSQL_ROOT_PASSWORD: "1234"  # MYSQL 패스워드 설정 옵션    command: # 명령어 실행    - --character-set-server=utf8mb4    - --collation-server=utf8mb4_unicode_ci    volumes:    - /Users/ddd/Documents/repository/To-do-list-noti2007/DB:/var/lib/mysql # -v 옵션 (다렉토리 마운트 설정)실행 방법은 docker-compose up -d 입니다.]]></content>
      <categories>
        
          <category> Docker </category>
        
      </categories>
      <tags>
        
          <tag> Docker </tag>
        
          <tag> DB </tag>
        
          <tag> MySQL </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Vue와 CMS를 이용하여 나의 개발 블로그 만들기]]></title>
      <url>/utility/2021/01/20/make-dev-blog/</url>
      <content type="text"><![CDATA[  개발 블로그 만들기경력은 쌓여가는데 슬프게도 개발 실력이 쌓이지 않는 불안감에서 시작하게되었고, 요즘 개발자들 사이에서 개인 블로그를 만든는 것이 유행이라는 말에 바로 만들어 보기로했다.😁개발하면서 고민하거나 겪었던 이슈를 기록하고 나와 다른 개발자들에게 도움이 될 수 있는 공간을 만들고 싶었고, 마지막으로 나의 커리어를 어필하는 용도로 블로그가 매우 적합하다고 생각했다.기술 스택 🔨  Back, Contentful of CMS  Front, Vue.js  Deploy, Nutify  Git  환경셋팅이 쉬운 기술을 이용하여 개발시간을 최대로 줄임 ( 저는 기술을 공부하고 사용한다고 5시간이나 걸림;;; )CMS란?  Contents Management System, 콘텐츠 관리 시스템사용이유  Back이 필요없이 프론트 &amp; 디자인으로만 웹 사이트를 만들어 낼 수 있음.  오픈소스라서 무료  기능 및 속도가 좋음  편하게 컨텐츠를 관리 가능  간단한 회사 홈페이지나 개인 홈페이지, 블로그 등은 CMS로 간단하게 만들 수 있음.Contentful api  CMS의 오픈소스 중 하나 5,000 엔티티까지 무료  워드프레스 사용자들은 익숙하게 사용 가능  여튼 직관적이여서 편해 보이며 사용 오픈소스가 많아보임컨텐츠 관리하는 화면, Status를 통해 글을 publish 할지 안할지 결정 가능글을 작성할때 필요한 템플릿을 커스텀하여 결정 가능컨텐츠를 작서하는 화면으로 Mark dowm을 지원하여 언어만 알고있다면 편하게 글 쓰기 가능, 또 그림등도 업로드후 URI를 통해 표현가능화면만들기 👨‍💻Vue.js를 이용하여 프론트를 만들어보았다. UI 라이브러리는 Vuetify를 이용하였다.작업 순서Contentful plugin을 설치한 후 import만 하면된다.      vue 프로젝트를 생성     vue create "PROJECT_NAME"            plugin을 설치     npm install contentfull            설치한 플러그인을 import     // ./plugins/contentful.js const contentful = require('contentful'); // use default environment config for convenience // these will be set via `env` property in nuxt.config.js const config = { 	space: process.env.VUE_APP_CTF_SPACE_ID, // Space id 	accessToken: process.env.VUE_APP_CTF_CDA_ACCESS_TOKEN, // Token }; // export `createClient` to use it in page components module.exports = { 	createClient() { 		return contentful.createClient(config); 	}, };         // app.vue &lt;script&gt; import ... import contentful from "@/plugins/contentful.js";  // import contentful const client = contentful.createClient(); // return createClient() export default {   name: "App",   data() {     return {};   },   components: {     appbar,     vfooter,     vview,   },   methods: {     setPosts(payload) {       this.$store.commit("setPosts", payload); // vuex의 state.posts에 넣는 메소드     },   }, // 프로젝트를 실행 할 때 모든 컨텐츠를 가지고와서 정적으로 사용할 예정 // Vuex의 state.posts 변수에 담김   mounted() {     client       .getEntries()       .then((response) =&gt; {         console.log(response.items);         this.setPosts(response.items);       })       .catch(console.error);   }, };      배포하기Nutify 를 이용해서 배포.Nutify란?GitHub, GitLab 계정 연동 및 쉬운 호스팅을 제공, 지속적 배포, One-Click HTTPS 제공해줌.사용이유  서버사이드 렌더링 지원  https 무료 지원  심플하고 깔끔한 인터페이스일단 contentful에 글을 쓸때나 git에서 push를 했을때 hook을 통해 자동으로 Build 작업을 해주는 아주 멋진 녀석🤣. 무료로 DNS를 제공해줌.진짜 쉬운 사용방법      깃허브 연결            호스팅 할려는 프로젝트 선택            브런치 선택 후 빌드되는 경로 선택            published          DNS를 자신이 원하는 것으로 바꿀수 있3      현재 배포 상테를 체크할 수 있음      github의 hook 연결과 contentful hook 연결을 통해 빌드 자동화 가능          ]]></content>
      <categories>
        
          <category> Utility </category>
        
      </categories>
      <tags>
        
          <tag> Vue.js </tag>
        
          <tag> CMS </tag>
        
          <tag> Nutify </tag>
        
          <tag> blog </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
</search>
